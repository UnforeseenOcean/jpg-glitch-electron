{"version":3,"sources":["webpack:///./node_modules/core-js/modules/es.array.from.js","webpack:///./src/util/electron.js","webpack:///./node_modules/core-js/modules/es.function.name.js","webpack:///./src/util/GlitchFile.js"],"names":["$","from","checkCorrectnessOfIteration","INCORRECT_ITERATION","iterable","Array","target","stat","forced","openFileDialog","dialogParams","remote","dialog","showOpenDialog","then","result","filePaths","Promise","all","map","loadFileFromHardDrive","Error","filePath","getExtension","isImageFilePath","fileType","getMimeTypeFromFilePath","blobURLFromImagePath","blobURL","glitchFilefromImageBlobURL","isGlitchFilePath","loadTextFile","fileData","fileContent","glitchFileFromJSON","reject","saveFile","glitchFile","glitchFileToJSON","json","saveTextFile","saveFileAs","saveDialogParams","properties","filters","name","extensions","defaultPath","showSaveDialog","canceled","exportFileAs","glitchBlobURL","blobUrlToBuffer","buffer","saveFileToDisk","DESCRIPTORS","defineProperty","f","FunctionPrototype","Function","prototype","FunctionPrototypeToString","toString","nameRE","NAME","configurable","get","call","this","match","error","GlitchFile","params","id","Date","now","Math","random","fileName","srcFilePath","srcFileType","srcBlobURL","history","isOnHardDrive","glitchFilefromFileInput","fileInputItem","fileReader","FileReader","isImg","resolve","onload","readerEvent","arrayBuffer","blobURLFromArrayBuffer","type","getFileName","content","readAsArrayBuffer","readAsText","JSON","parse","toArrayBuffer","srcBuffer","err","fetchBlob","blob","Response","fileContents","Uint8Array","stringify"],"mappings":"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","file":"js/chunk-853b758e.500f9fb5.js","sourcesContent":["var $ = require('../internals/export');\nvar from = require('../internals/array-from');\nvar checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');\n\nvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n  Array.from(iterable);\n});\n\n// `Array.from` method\n// https://tc39.github.io/ecma262/#sec-array.from\n$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {\n  from: from\n});\n","import { remote } from 'electron';\nimport { getExtension, isImageFilePath, isGlitchFilePath } from '@/util/path.js';\nimport { blobURLFromImagePath } from '@/util/image.js';\nimport { loadTextFile, saveTextFile, saveFile as saveFileToDisk, blobUrlToBuffer } from '@/util/file.js';\nimport { lookup as getMimeTypeFromFilePath } from 'mime-types';\nimport { glitchFilefromImageBlobURL, glitchFileFromJSON, glitchFileToJSON } from '@/util/GlitchFile.js';\n\nexport function openFileDialog ( dialogParams ) {\n\treturn remote.dialog.showOpenDialog( dialogParams )\n\t\t.then( result => {\n\t\t\tif ( result.filePaths ) {\n\t\t\t\treturn Promise.all( result.filePaths.map( loadFileFromHardDrive ) )\n\t\t\t} else {\n\t\t\t\tthrow new Error( 'Could not open files.' );\n\t\t\t}\n\t\t} );\n}\n\nexport function loadFileFromHardDrive ( filePath ) {\n\tconst extension = getExtension( filePath );\n\n\tif ( isImageFilePath( filePath ) ) {\n\t\tconst fileType = getMimeTypeFromFilePath( filePath );\n\n\t\treturn blobURLFromImagePath( filePath )\n\t\t\t.then( blobURL => {\n\t\t\t\treturn glitchFilefromImageBlobURL( blobURL, filePath, fileType );\n\t\t\t} );\n\t} else {\n\t\tif ( isGlitchFilePath( filePath ) )\t {\n\t\t\treturn loadTextFile( filePath )\n\t\t\t\t.then( fileData => {\n\t\t\t\t\tconst { filePath, fileContent } = fileData;\n\n\t\t\t\t\treturn glitchFileFromJSON( fileContent, filePath, true );\n\t\t\t\t} );\n\t\t} else {\n\t\t\t// console.log( 'cant handle', filePath, isGlitchFilePath( filePath ) );\n\t\t\treturn Promise.reject( new Error( 'Could not handle file type of file:' + filePath ) );\n\t\t}\n\t}\n}\n\nexport function saveFile ( glitchFile, filePath = null ) {\n\tif ( ! filePath ) {\n\t\tfilePath = glitchFile.filePath;\n\t}\n\n\tif ( filePath ) {\n\t\t// console.log( 'STORING FILE....', filePath );\n\t\treturn glitchFileToJSON( glitchFile )\n\t\t\t.then( json => saveTextFile( filePath, json ) );\n\t} else {\n\t\t// console.log( 'NO FILE PATH!', filePath );\n\t\treturn Promise.reject( new Error( 'No file path was given' ) );\n\t}\n}\n\nexport function saveFileAs ( glitchFile ) {\n\tconst saveDialogParams = {\n\t\tproperties: [ 'openFile', 'multiSelections' ],\n\t\tfilters: [\n\t\t\t{ name: 'Images', extensions: [ 'glitch' ] }\n\t\t],\n\t\tdefaultPath: glitchFile.filePath\n\t};\n\n\treturn remote.dialog.showSaveDialog( saveDialogParams )\n\t\t.then( result => {\n\t\t\tif ( result.filePath ) {\n\t\t\t\treturn saveFile( glitchFile, result.filePath );\n\t\t\t} else {\n\t\t\t\tif ( result.canceled ) {\n\t\t\t\t\t// console.log( 'Save was canceled' );\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error( 'Could not save file' );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\treturn saveTextFile( glitchFile.fileName + '.glitch', json );\n}\n\nexport function exportFileAs ( glitchFile ) {\n\tif ( glitchFile.glitchBlobURL ) {\n\t\tconst saveDialogParams = {\n\t\tproperties: [ 'openFile', 'multiSelections' ],\n\t\tfilters: [\n\t\t\t{ name: 'Images', extensions: [ 'png' ] }\n\t\t]\n\t};\n\n\treturn remote.dialog.showSaveDialog( saveDialogParams )\n\t\t.then( result => {\n\t\t\tif ( result.filePath ) {\n\t\t\t\treturn blobUrlToBuffer( glitchFile.glitchBlobURL )\n\t\t\t\t\t.then( buffer => saveFileToDisk( result.filePath, buffer, 'binary' ) );\n\t\t\t} else {\n\t\t\t\tif ( result.canceled ) {\n\t\t\t\t\t// console.log( 'Save was canceled' );\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error( 'Could not save file' );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t} else {\n\t\treturn Promise.reject( new Error( 'Could not export glitch file: No glitchBlobURL found.' ) );\n\t}\n}\n","var DESCRIPTORS = require('../internals/descriptors');\nvar defineProperty = require('../internals/object-define-property').f;\n\nvar FunctionPrototype = Function.prototype;\nvar FunctionPrototypeToString = FunctionPrototype.toString;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// Function instances `.name` property\n// https://tc39.github.io/ecma262/#sec-function-instances-name\nif (DESCRIPTORS && !(NAME in FunctionPrototype)) {\n  defineProperty(FunctionPrototype, NAME, {\n    configurable: true,\n    get: function () {\n      try {\n        return FunctionPrototypeToString.call(this).match(nameRE)[1];\n      } catch (error) {\n        return '';\n      }\n    }\n  });\n}\n","import { isImageFilePath, isGlitchFilePath, getFileName } from '@/util/path.js';\nimport { toArrayBuffer } from '@/util/buffer.js';\nimport { getBlobURL, blobURLFromArrayBuffer } from '@/util/image.js';\nimport { fetchBlob } from '@/util/file.js';\nimport { arrayBufferToBlob } from 'blob-util';\n\nexport class GlitchFile {\n\tconstructor( params = { } ) {\n\t\t// unique id\n\t\tthis.id = params.id || Date.now() + '_' + ~~( Math.random() * 10000 );\n\t\t\n\t\t// fileName: without extension\n\t\tthis.fileName = params.fileName || 'Untitled';\n\n\t\t// electron: complete path\n\t\t// browser: fileName with extension\n\t\tthis.filePath = params.filePath || `${this.fileName}.glitch`;\n\n\t\t// name of the original image file\n\t\tthis.srcFilePath = params.srcFilePath || `${this.fileName}.jpg`;\n\t\tthis.srcFileType = params.srcFileType;\n\n\t\tthis.srcBlobURL = params.srcBlobURL;\n\n\t\tthis.history = params.history || [ ];\n\t\tthis.glitchBlobURL = null;\n\n\t\tthis.isOnHardDrive = !! params.isOnHardDrive;\n\t}\n}\n\t\nexport function glitchFilefromFileInput ( fileInputItem ) {\n\tconst fileReader = new FileReader();\n\tconst isImg = isImageFilePath( fileInputItem.name );\n\n\treturn new Promise( ( resolve, reject ) => {\n\t\tfileReader.onload = readerEvent => {\n\t\t\tif ( isImg ) {\n\t\t\t\tconst arrayBuffer = readerEvent.target.result;\n\t\t\t\tconst blobURL = blobURLFromArrayBuffer( arrayBuffer, fileInputItem.type );\n\n\t\t\t\tconst glitchFile = new GlitchFile( {\n\t\t\t\t\tfileName: getFileName( fileInputItem.name ),\n\t\t\t\t\tsrcFilePath: fileInputItem.name,\n\t\t\t\t\tsrcBlobURL: blobURL,\n\t\t\t\t\tsrcFileType: fileInputItem.type\n\t\t\t\t} );\n\n\t\t\t\tresolve( glitchFile );\n\t\t\t} else {\n\t\t\t\tconst content = readerEvent.target.result;\n\t\t\t\t\n\t\t\t\tif ( isGlitchFilePath( fileInputItem.name ) ) {\n\t\t\t\t\tconst glitchFile = glitchFileFromJSON( content );\n\t\t\t\t\tresolve( glitchFile );\n\t\t\t\t} else {\n\t\t\t\t\treject( new Error( `Can't handle file: ${fileInputItem.name}: Was expecting it to be in JSON format.` ) );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tif ( isImg ) {\n\t\t\tfileReader.readAsArrayBuffer( fileInputItem );\n\t\t} else {\n\t\t\tfileReader.readAsText( fileInputItem );\n\t\t}\n\t} );\n}\n\nexport function glitchFilefromImageBlobURL ( srcBlobURL, srcFilePath = null, srcFileType = null ) {\n\tconst fileName = srcFilePath ? getFileName( srcFilePath ) : null;\n\t\n\treturn new GlitchFile( {\n\t\tfileName,\n\t\tsrcFilePath,\n\t\tsrcBlobURL,\n\t\tsrcFileType\n\t} );\n}\n\nexport function glitchFileFromJSON ( json, filePath = null, isOnHardDrive = false ) {\n\ttry {\n\t\tconst fileData = JSON.parse( json );\n\t\tconst arrayBuffer = toArrayBuffer( fileData.srcBuffer );\n\t\tconst srcBlobURL = blobURLFromArrayBuffer( arrayBuffer, fileData.srcFileType );\n\n\t\tfileData.srcBlobURL = srcBlobURL;\n\t\tfileData.isOnHardDrive = isOnHardDrive;\n\n\t\tif ( filePath ) {\n\t\t\tfileData.filePath = filePath;\n\t\t\tfileData.fileName = getFileName( filePath );\n\t\t}\n\n\t\tconst glitchFile = new GlitchFile( fileData );\n\n\t\t// console.log( 'GLITCH FILE IMPORT', glitchFile );\n\t\treturn glitchFile;\n\t} catch ( err ) {\n\t\t// console.log( 'FAILED GLITCH FILE', err );\n\t\tPromise.reject( err );\n\t}\n}\n\nexport function glitchFileToJSON ( glitchFile ) {\n\treturn fetchBlob( glitchFile.srcBlobURL )\n\t\t.then( blob => new Response( blob ).arrayBuffer() )\n\t\t.then( srcBuffer => {\n\t\t\tconst fileContents = {\n\t\t\t\tfileName: glitchFile.fileName,\n\t\t\t\tsrcBuffer: Array.from( new Uint8Array( srcBuffer ) ),\n\t\t\t\thistory: glitchFile.history\n\t\t\t};\n\n\t\t\treturn JSON.stringify( fileContents );\n\t\t} );\n}"],"sourceRoot":""}