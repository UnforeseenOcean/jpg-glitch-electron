{"version":3,"sources":["webpack:///./node_modules/core-js/modules/es.array.from.js","webpack:///./src/util/browser.js","webpack:///./node_modules/core-js/modules/es.function.name.js","webpack:///./src/util/GlitchFile.js"],"names":["$","from","checkCorrectnessOfIteration","INCORRECT_ITERATION","iterable","Array","target","stat","forced","inputEl","initFileInputField","document","querySelector","onchange","event","files","filePromises","map","file","glitchFilefromFileInput","Promise","all","then","glitchFiles","store","dispatch","exportFileAs","glitchFile","glitchBlobURL","Error","linkEl","createElement","style","body","appendChild","download","getFileName","fileName","href","click","removeChild","saveFileAs","glitchFileToJSON","json","fileBlob","Blob","type","blobURL","URL","createObjectURL","revokeObjectURL","DESCRIPTORS","defineProperty","f","FunctionPrototype","Function","prototype","FunctionPrototypeToString","toString","nameRE","NAME","configurable","get","call","this","match","error","GlitchFile","params","id","Date","now","Math","random","filePath","srcFilePath","srcFileType","srcBlobURL","history","isOnHardDrive","fileInputItem","fileReader","FileReader","isImg","isImageFilePath","name","resolve","reject","onload","readerEvent","arrayBuffer","result","blobURLFromArrayBuffer","content","isGlitchFilePath","glitchFileFromJSON","readAsArrayBuffer","readAsText","glitchFilefromImageBlobURL","fileData","JSON","parse","toArrayBuffer","srcBuffer","err","fetchBlob","blob","Response","fileContents","Uint8Array","stringify"],"mappings":"mGAAA,IAAIA,EAAI,EAAQ,QACZC,EAAO,EAAQ,QACfC,EAA8B,EAAQ,QAEtCC,GAAuBD,GAA4B,SAAUE,GAC/DC,MAAMJ,KAAKG,MAKbJ,EAAE,CAAEM,OAAQ,QAASC,MAAM,EAAMC,OAAQL,GAAuB,CAC9DF,KAAMA,K,kSCNJQ,EAAU,KAEP,SAASC,IACRD,IAINA,EAAUE,SAASC,cAAe,eAElCH,EAAQI,SAAW,SAAAC,GAElB,IAAMC,EAAQD,EAAMR,OAAOS,MACrBC,EAAeX,MAAMJ,KAAMc,GAC/BE,KAAK,SAAAC,GAAI,OAAIC,eAAyBD,MAExCE,QACEC,IAAKL,GACLM,MAAM,SAAAC,GACNC,OAAMC,SAAU,YAAaF,QAM3B,SAASG,EAAeC,GAC9B,IAAKA,EAAWC,cAYf,MAAM,IAAIC,MAAJ,qCAXN,IAAMC,EAASnB,SAASoB,cAAe,KACvCD,EAAOE,MAAQ,gBAEfrB,SAASsB,KAAKC,YAAaJ,GAE3BA,EAAOK,SAAWC,eAAaT,EAAWU,UAAa,OACvDP,EAAOQ,KAAOX,EAAWC,cACzBE,EAAOS,QAEP5B,SAASsB,KAAKO,YAAaV,GAMtB,SAASW,EAAad,GAC5B,OAAOe,eAAkBf,GACvBL,MAAM,SAAAqB,GACN,IAAMC,EAAW,IAAIC,KAAM,CAAEF,GAAQ,CAAEG,KAAM,iBACjCC,EAAUC,IAAIC,gBAAiBL,GAErCd,EAASnB,SAASoB,cAAe,KACvCD,EAAOE,MAAQ,gBAEfrB,SAASsB,KAAKC,YAAaJ,GAE3BA,EAAOK,SAAWC,eAAaT,EAAWU,UAAa,UACvDP,EAAOQ,KAAOS,EACdjB,EAAOS,QAEP5B,SAASsB,KAAKO,YAAaV,GAC3BkB,IAAIE,gBAAiBH,Q,qBC9DxB,IAAII,EAAc,EAAQ,QACtBC,EAAiB,EAAQ,QAAuCC,EAEhEC,EAAoBC,SAASC,UAC7BC,EAA4BH,EAAkBI,SAC9CC,EAAS,wBACTC,EAAO,OAIPT,KAAiBS,KAAQN,IAC3BF,EAAeE,EAAmBM,EAAM,CACtCC,cAAc,EACdC,IAAK,WACH,IACE,OAAOL,EAA0BM,KAAKC,MAAMC,MAAMN,GAAQ,GAC1D,MAAOO,GACP,MAAO,Q,4gBCXFC,G,UACZ,aAA4B,IAAfC,EAAe,uDAAN,GAAM,uBAE3BJ,KAAKK,GAAKD,EAAOC,IAAMC,KAAKC,MAAQ,OAA0B,IAAhBC,KAAKC,UAGnDT,KAAK3B,SAAW+B,EAAO/B,UAAY,WAInC2B,KAAKU,SAAWN,EAAOM,UAAP,UAAsBV,KAAK3B,SAA3B,WAGhB2B,KAAKW,YAAcP,EAAOO,aAAP,UAAyBX,KAAK3B,SAA9B,QACnB2B,KAAKY,YAAcR,EAAOQ,YAE1BZ,KAAKa,WAAaT,EAAOS,WAEzBb,KAAKc,QAAUV,EAAOU,SAAW,GACjCd,KAAKpC,cAAgB,KAErBoC,KAAKe,gBAAmBX,EAAOW,gBAI1B,SAAS5D,EAA0B6D,GACzC,IAAMC,EAAa,IAAIC,WACjBC,EAAQC,eAAiBJ,EAAcK,MAE7C,OAAO,IAAIjE,SAAS,SAAEkE,EAASC,GAC9BN,EAAWO,OAAS,SAAAC,GACnB,GAAKN,EAAQ,CACZ,IAAMO,EAAcD,EAAYnF,OAAOqF,OACjC5C,EAAU6C,eAAwBF,EAAaV,EAAclC,MAE7DnB,EAAa,IAAIwC,EAAY,CAClC9B,SAAUD,eAAa4C,EAAcK,MACrCV,YAAaK,EAAcK,KAC3BR,WAAY9B,EACZ6B,YAAaI,EAAclC,OAG5BwC,EAAS3D,OACH,CACN,IAAMkE,EAAUJ,EAAYnF,OAAOqF,OAEnC,GAAKG,eAAkBd,EAAcK,MAAS,CAC7C,IAAM1D,EAAaoE,EAAoBF,GACvCP,EAAS3D,QAET4D,EAAQ,IAAI1D,MAAJ,6BAAiCmD,EAAcK,KAA/C,gDAKNF,EACJF,EAAWe,kBAAmBhB,GAE9BC,EAAWgB,WAAYjB,MAKnB,SAASkB,EAA6BrB,GAAqD,IAAzCF,EAAyC,uDAA3B,KAAMC,EAAqB,uDAAP,KACpFvC,EAAWsC,EAAcvC,eAAauC,GAAgB,KAE5D,OAAO,IAAIR,EAAY,CACtB9B,WACAsC,cACAE,aACAD,gBAIK,SAASmB,EAAqBpD,GAA+C,IAAzC+B,EAAyC,uDAA9B,KAAMK,EAAwB,wDACnF,IACC,IAAMoB,EAAWC,KAAKC,MAAO1D,GACvB+C,EAAcY,eAAeH,EAASI,WACtC1B,EAAae,eAAwBF,EAAaS,EAASvB,aAEjEuB,EAAStB,WAAaA,EACtBsB,EAASpB,cAAgBA,EAEpBL,IACJyB,EAASzB,SAAWA,EACpByB,EAAS9D,SAAWD,eAAasC,IAGlC,IAAM/C,EAAa,IAAIwC,EAAYgC,GAGnC,OAAOxE,EACN,MAAQ6E,GAETpF,QAAQmE,OAAQiB,IAIX,SAAS9D,EAAmBf,GAClC,OAAO8E,eAAW9E,EAAWkD,YAC3BvD,MAAM,SAAAoF,GAAI,OAAI,IAAIC,SAAUD,GAAOhB,iBACnCpE,MAAM,SAAAiF,GACN,IAAMK,EAAe,CACpBvE,SAAUV,EAAWU,SACrBkE,UAAWlG,MAAMJ,KAAM,IAAI4G,WAAYN,IACvCzB,QAASnD,EAAWmD,SAGrB,OAAOsB,KAAKU,UAAWF","file":"js/chunk-2f3394ca.1c0c3e3a.js","sourcesContent":["var $ = require('../internals/export');\nvar from = require('../internals/array-from');\nvar checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');\n\nvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n  Array.from(iterable);\n});\n\n// `Array.from` method\n// https://tc39.github.io/ecma262/#sec-array.from\n$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {\n  from: from\n});\n","import { blobURLFromArrayBuffer } from '@/util/image.js';\nimport { isImageFilePath, getExtension, getFileName } from '@/util/path.js';\nimport { glitchFilefromFileInput, glitchFileToJSON } from '@/util/GlitchFile.js';\nimport store from '@/store/index.js';\n\nlet inputEl = null;\n\nexport function initFileInputField () {\n\tif ( ! inputEl ) {\n\t\t// the input element is added in public/index.html\n\t\t// because some browsers won't work with a file\n\t\t// input field created in javascript\n\t\tinputEl = document.querySelector( '#file-input' );\n\n\t\tinputEl.onchange = event => { \n\n\t\t\tconst files = event.target.files;\n\t\t\tconst filePromises = Array.from( files )\n\t\t\t\t.map( file => glitchFilefromFileInput( file ) );\n\n\t\t\tPromise\n\t\t\t\t.all( filePromises )\n\t\t\t\t.then( glitchFiles => {\n\t\t\t\t\tstore.dispatch( 'openFiles', glitchFiles );\n\t\t\t\t} );\n\t\t}\n\t}\n}\n\nexport function exportFileAs ( glitchFile ) {\n\tif ( glitchFile.glitchBlobURL ) {\n\t\tconst linkEl = document.createElement( 'a' );\n\t\tlinkEl.style = 'display: none';\n\t\t\n\t\tdocument.body.appendChild( linkEl );\n\n\t\tlinkEl.download = getFileName( glitchFile.fileName ) + '.png';\n\t\tlinkEl.href = glitchFile.glitchBlobURL;\n\t\tlinkEl.click();\n\n\t\tdocument.body.removeChild( linkEl );\n\t} else {\n\t\tthrow new Error( `File doesn't have a glitchBlobURL` );\n\t}\n}\n\nexport function saveFileAs ( glitchFile ) {\n\treturn glitchFileToJSON( glitchFile )\n\t\t.then( json => {\n\t\t\tconst fileBlob = new Blob( [ json ], { type: 'octet/stream' } );\n        \tconst blobURL = URL.createObjectURL( fileBlob );\n\n\t\t\tconst linkEl = document.createElement( 'a' );\n\t\t\tlinkEl.style = 'display: none';\n\t\t\t\n\t\t\tdocument.body.appendChild( linkEl );\n\n\t\t\tlinkEl.download = getFileName( glitchFile.fileName ) + '.glitch';\n\t\t\tlinkEl.href = blobURL;\n\t\t\tlinkEl.click();\n\n\t\t\tdocument.body.removeChild( linkEl );\n\t\t\tURL.revokeObjectURL( blobURL );\n\t\t} );\n}","var DESCRIPTORS = require('../internals/descriptors');\nvar defineProperty = require('../internals/object-define-property').f;\n\nvar FunctionPrototype = Function.prototype;\nvar FunctionPrototypeToString = FunctionPrototype.toString;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// Function instances `.name` property\n// https://tc39.github.io/ecma262/#sec-function-instances-name\nif (DESCRIPTORS && !(NAME in FunctionPrototype)) {\n  defineProperty(FunctionPrototype, NAME, {\n    configurable: true,\n    get: function () {\n      try {\n        return FunctionPrototypeToString.call(this).match(nameRE)[1];\n      } catch (error) {\n        return '';\n      }\n    }\n  });\n}\n","import { isImageFilePath, isGlitchFilePath, getFileName } from '@/util/path.js';\nimport { toArrayBuffer } from '@/util/buffer.js';\nimport { getBlobURL, blobURLFromArrayBuffer } from '@/util/image.js';\nimport { fetchBlob } from '@/util/file.js';\nimport { arrayBufferToBlob } from 'blob-util';\n\nexport class GlitchFile {\n\tconstructor( params = { } ) {\n\t\t// unique id\n\t\tthis.id = params.id || Date.now() + '_' + ~~( Math.random() * 10000 );\n\t\t\n\t\t// fileName: without extension\n\t\tthis.fileName = params.fileName || 'Untitled';\n\n\t\t// electron: complete path\n\t\t// browser: fileName with extension\n\t\tthis.filePath = params.filePath || `${this.fileName}.glitch`;\n\n\t\t// name of the original image file\n\t\tthis.srcFilePath = params.srcFilePath || `${this.fileName}.jpg`;\n\t\tthis.srcFileType = params.srcFileType;\n\n\t\tthis.srcBlobURL = params.srcBlobURL;\n\n\t\tthis.history = params.history || [ ];\n\t\tthis.glitchBlobURL = null;\n\n\t\tthis.isOnHardDrive = !! params.isOnHardDrive;\n\t}\n}\n\t\nexport function glitchFilefromFileInput ( fileInputItem ) {\n\tconst fileReader = new FileReader();\n\tconst isImg = isImageFilePath( fileInputItem.name );\n\n\treturn new Promise( ( resolve, reject ) => {\n\t\tfileReader.onload = readerEvent => {\n\t\t\tif ( isImg ) {\n\t\t\t\tconst arrayBuffer = readerEvent.target.result;\n\t\t\t\tconst blobURL = blobURLFromArrayBuffer( arrayBuffer, fileInputItem.type );\n\n\t\t\t\tconst glitchFile = new GlitchFile( {\n\t\t\t\t\tfileName: getFileName( fileInputItem.name ),\n\t\t\t\t\tsrcFilePath: fileInputItem.name,\n\t\t\t\t\tsrcBlobURL: blobURL,\n\t\t\t\t\tsrcFileType: fileInputItem.type\n\t\t\t\t} );\n\n\t\t\t\tresolve( glitchFile );\n\t\t\t} else {\n\t\t\t\tconst content = readerEvent.target.result;\n\t\t\t\t\n\t\t\t\tif ( isGlitchFilePath( fileInputItem.name ) ) {\n\t\t\t\t\tconst glitchFile = glitchFileFromJSON( content );\n\t\t\t\t\tresolve( glitchFile );\n\t\t\t\t} else {\n\t\t\t\t\treject( new Error( `Can't handle file: ${fileInputItem.name}: Was expecting it to be in JSON format.` ) );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tif ( isImg ) {\n\t\t\tfileReader.readAsArrayBuffer( fileInputItem );\n\t\t} else {\n\t\t\tfileReader.readAsText( fileInputItem );\n\t\t}\n\t} );\n}\n\nexport function glitchFilefromImageBlobURL ( srcBlobURL, srcFilePath = null, srcFileType = null ) {\n\tconst fileName = srcFilePath ? getFileName( srcFilePath ) : null;\n\t\n\treturn new GlitchFile( {\n\t\tfileName,\n\t\tsrcFilePath,\n\t\tsrcBlobURL,\n\t\tsrcFileType\n\t} );\n}\n\nexport function glitchFileFromJSON ( json, filePath = null, isOnHardDrive = false ) {\n\ttry {\n\t\tconst fileData = JSON.parse( json );\n\t\tconst arrayBuffer = toArrayBuffer( fileData.srcBuffer );\n\t\tconst srcBlobURL = blobURLFromArrayBuffer( arrayBuffer, fileData.srcFileType );\n\n\t\tfileData.srcBlobURL = srcBlobURL;\n\t\tfileData.isOnHardDrive = isOnHardDrive;\n\n\t\tif ( filePath ) {\n\t\t\tfileData.filePath = filePath;\n\t\t\tfileData.fileName = getFileName( filePath );\n\t\t}\n\n\t\tconst glitchFile = new GlitchFile( fileData );\n\n\t\t// console.log( 'GLITCH FILE IMPORT', glitchFile );\n\t\treturn glitchFile;\n\t} catch ( err ) {\n\t\t// console.log( 'FAILED GLITCH FILE', err );\n\t\tPromise.reject( err );\n\t}\n}\n\nexport function glitchFileToJSON ( glitchFile ) {\n\treturn fetchBlob( glitchFile.srcBlobURL )\n\t\t.then( blob => new Response( blob ).arrayBuffer() )\n\t\t.then( srcBuffer => {\n\t\t\tconst fileContents = {\n\t\t\t\tfileName: glitchFile.fileName,\n\t\t\t\tsrcBuffer: Array.from( new Uint8Array( srcBuffer ) ),\n\t\t\t\thistory: glitchFile.history\n\t\t\t};\n\n\t\t\treturn JSON.stringify( fileContents );\n\t\t} );\n}"],"sourceRoot":""}